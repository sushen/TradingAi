The problem is in the database. My column don't have the time table.
because it didn't find the time base index so it become unable to calculate all those other things
but aside that problem.

Let me share you two Scripts:
"""
Script Name: observation.py
Author: Sushen Biswas
Date: 2023-03-26
"""
import sys
import os

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import sqlite3
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from all_variable import Variable
from database_small.db_dataframe import GetDbDataframe

import time
start_time = time.time()
print("Script Start :", time.ctime())

# Set database path from Variable class
database = Variable.SMALL_DATABASE
# database = Variable.BIG_DATABASE

# Convert to absolute path
absolute_path = os.path.abspath(database)
print(f"Database path: {absolute_path}")

# Initialize global constants
LOOKBACK = 1440/32  # Lookback of 1 year (1440 minutes per day)
TOTAL_SUM = 500  # Updated total_sum to 1500
TIME_PERIODS = [1, 3, 5, 15, 30, 60, 4 * 60, 24 * 60, 7 * 24 * 60]  # Time periods

def get_database_connection():
    """Returns a connection to the SQLite database."""
    connection = sqlite3.connect(database)
    return connection


def fetch_resampled_data(symbol, time_period, lookback, db_frame):
    """Fetches resampled data and indicators for a given time period."""
    resampled_data = db_frame.get_minute_data(symbol, time_period, lookback)
    df = db_frame.get_all_indicators(symbol, time_period, lookback)

    # Debugging: Check the raw data and the indicators
    print(f"Raw Data for {symbol} at {time_period} minutes:")
    # print(resampled_data.head())  # Print the first few rows of raw data
    # print(f"Indicator Data for {symbol} at {time_period} minutes:")
    # print(df.head())  # Print the first few rows of indicator data

    # Debugging: Check for NaN values in resampled data and indicators


    df.index = resampled_data.index
    resampled_data = resampled_data[~resampled_data.index.duplicated(keep='first')]
    all_indicator_df = df[~df.index.duplicated(keep='first')]

    # print(f"(resampled_data:  {resampled_data}")
    print(f"(resampled_all_indicator_data_df:  {all_indicator_df}")


    return resampled_data, all_indicator_df



def calculate_total_sum(resampled_data, df):
    """Calculates the total sum of indicators and adds it to the resampled data."""
    resampled_data['sum'] = df.sum(axis=1)
    return resampled_data


def print_indicators_and_sum(resampled_data, df, total_sum_values, symbol):
    """Prints the sum and the indicators contributing to buy/sell signals."""
    MIN_INDICATOR_THRESHOLD = 0.1  # Minimum threshold for considering indicator values

    # Reindex df to match resampled_data index
    df = df.reindex(resampled_data.index)

    for index in resampled_data.index:
        # print(f"Checking index: {index} with total_sum: {total_sum_values[index]}")  # Debug line

        p_cols = [col + f"({str(df.loc[index, col])})" for col in df.columns if df.loc[index, col] != 0]
        p = f"Sum: {resampled_data['sum'][index]}  indicators: {', '.join(p_cols)}"
        # print(p)

        # Ensure the index exists in both dataframes
        if index in df.index:
            # Print all the indicator values for each timestamp
            for col in df.columns:
                indicator_value = df[col].loc[index]
                # print(f"{col}: {indicator_value}")  # Debug print for each indicator value

            if total_sum_values[index] >= TOTAL_SUM:
                indicators_contributing = []
                for col in df.columns:
                    indicator_value = df[col].loc[index]
                    if indicator_value > MIN_INDICATOR_THRESHOLD:  # Only consider significant positive values
                        indicators_contributing.append(f'{col}({indicator_value:.2f})')
                if indicators_contributing:
                    print(f"Sum: {total_sum_values[index]}  Indicators: {', '.join(indicators_contributing)}")
                else:
                    print(f"No contributing indicators for Buy Signal at {index}")
            elif total_sum_values[index] <= -TOTAL_SUM:
                indicators_contributing = []
                for col in df.columns:
                    indicator_value = df[col].loc[index]
                    if indicator_value < -MIN_INDICATOR_THRESHOLD:  # Only consider significant negative values
                        indicators_contributing.append(f'{col}({indicator_value:.2f})')
                if indicators_contributing:
                    print(f"Sum: {total_sum_values[index]}  Indicators: {', '.join(indicators_contributing)}")
                else:
                    print(f"No contributing indicators for Sell Signal at {index}")
        else:
            print(f"Index {index} not found in df index")

    # Time Counting
    import time
    end_time = time.time()
    print("End Time: ", end_time)
    print("Script is running for Creat Indicator" + str(int((end_time - start_time) / 60)) + " Minutes.")



def plot_signals(resampled_data, total_sum_values, symbol, df):
    """Plots the close price along with buy and sell signals, and prints the indicators."""
    marker_sizes = np.abs(resampled_data['sum']) / 10

    # Print the indicators contributing to buy/sell signals
    print_indicators_and_sum(resampled_data, df, total_sum_values, symbol)

    # Plot the close price
    plt.figure(figsize=(14, 7))  # Set figure size for better visualization
    plt.plot(resampled_data['Close'], label='Close Price', color='blue', linewidth=1.5)

    # Buy and sell signal markers
    buy_indices = resampled_data.index[resampled_data['sum'] >= TOTAL_SUM]
    sell_indices = resampled_data.index[resampled_data['sum'] <= -TOTAL_SUM]

    plt.scatter(buy_indices, resampled_data['Close'][resampled_data['sum'] >= TOTAL_SUM],
                marker='^', s=marker_sizes[resampled_data['sum'] >= TOTAL_SUM], color='green', zorder=3,
                label='Buy Signal')
    plt.scatter(sell_indices, resampled_data['Close'][resampled_data['sum'] <= -TOTAL_SUM],
                marker='v', s=marker_sizes[resampled_data['sum'] <= -TOTAL_SUM], color='red', zorder=3,
                label='Sell Signal')

    # Add text labels for sum values
    for index in buy_indices:
        plt.text(index, resampled_data['Close'][index], f'{resampled_data["sum"][index]}',
                 ha='center', va='bottom', fontsize=8, color='green', fontweight='bold')
    for index in sell_indices:
        plt.text(index, resampled_data['Close'][index], f'{resampled_data["sum"][index]}',
                 ha='center', va='top', fontsize=8, color='red', fontweight='bold')

    # Time Counting
    import time
    end_time = time.time()
    print("End Time: ", end_time)
    print("Script is running for Creating Plot " + str(int((end_time - start_time) / 60)) + " Minutes.")

    # Title and Labels
    plt.title(f'{symbol} Price with Buy/Sell Signals', fontsize=16)
    plt.xlabel('Time', fontsize=12)
    plt.ylabel('Price (USD)', fontsize=12)
    plt.legend()
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.xticks(rotation=45)  # Rotate x-axis labels for better readability
    plt.tight_layout()  # Adjust the layout to prevent clipping
    # Full screen mode
    # plt.get_current_fig_manager().full_screen_toggle()
    plt.show()

def main(symbol):
    """Main function to run the entire process."""
    pd.set_option('mode.chained_assignment', None)
    pd.set_option('display.max_rows', 500)
    pd.set_option('display.max_columns', 500)
    pd.set_option('display.width', 1000)

    # Get database connection and fetch data
    connection = get_database_connection()
    db_frame = GetDbDataframe(connection)

    total_sum_values = pd.Series(0, index=pd.DatetimeIndex([]))

    # Resample data for each time period and accumulate the sum
    for time in TIME_PERIODS:
        resampled_data, df = fetch_resampled_data(symbol, time, LOOKBACK, db_frame)
        resampled_data = calculate_total_sum(resampled_data, df)

        # Add the sum to the total sum
        total_sum_values = total_sum_values.add(resampled_data['sum'], fill_value=0)

    total_sum_values = total_sum_values.fillna(0).astype(np.int16)

    # Final resampled data and plot
    resampled_data = db_frame.get_minute_data(symbol, 1, LOOKBACK)
    resampled_data['sum'] = total_sum_values

    # Corrected function call: pass `symbol` as the third argument
    plot_signals(resampled_data, total_sum_values, symbol, df)


# Call the function for BTCUSDT
if __name__ == "__main__":
    main("BTCUSDT")

And

"""
Script Name: main.py
Author: Sushen Biswas
Date: 2023-03-26
"""

import os
import sys
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import time
import numpy as np
import sqlite3
from database.db_dataframe import GetDbDataframe
from database.exchange_info import BinanceExchange
from datetime import datetime
from database.missing_data_single_symbol import MissingDataCollection
from playsound import playsound

database = "database/big_crypto_4years.db"

def main():
    import pandas as pd

    pd.set_option('mode.chained_assignment', None)
    pd.set_option('display.max_rows', 500)
    pd.set_option('display.max_columns', 500)
    pd.set_option('display.width', 1000)

    # Specify symbol directly
    target_symbol = "BTCUSDT"
    missing_data = MissingDataCollection(database=database)
    missing_data.collect_missing_data_single_symbols(target_symbol)

    print(f"Processing symbol: {target_symbol}")

    # Fetch the required symbol's information
    connection = sqlite3.connect(database)
    db_frame = GetDbDataframe(connection)
    data = db_frame.get_minute_data(target_symbol, 1, 90)
    df = db_frame.get_all_indicators(target_symbol, 1, 90)
    df.index = data.index
    df = df.add_prefix("1_")
    data['sum'] = df.sum(axis=1)
    times = [3, 5, 15, 30, 60, 4 * 60, 24 * 60, 7 * 24 * 60]
    total_sum_values = pd.Series(0, index=pd.DatetimeIndex([]))
    total_sum_values = total_sum_values.add(data['sum'], fill_value=0)

    for time in times:
        temp_data = db_frame.get_minute_data(target_symbol, time, 90)
        temp_df = db_frame.get_all_indicators(target_symbol, time, 90)
        temp_df.index = temp_data.index
        temp_data = temp_data[~temp_data.index.duplicated(keep='first')]
        temp_df = temp_df[~temp_df.index.duplicated(keep='first')]
        temp_df = temp_df.add_prefix(f"{time}m_")
        df = pd.concat([df, temp_df], axis=1)
        temp_data['sum'] = temp_df.sum(axis=1)
        total_sum_values = total_sum_values.add(temp_data['sum'], fill_value=0)

        # Print last 5 sum for each timeframe
        print(f"Last 5 sum for {time}m:")
        print(temp_data['sum'][-5:])

    total_sum_values = total_sum_values.fillna(0).astype(np.int16)
    df.fillna(0, inplace=True)
    data['sum'] = total_sum_values

    total_sum = 500

    print("Last 5 overall sum:")
    print(data['sum'][-5:])
    if not (any(data['sum'][-5:] >= total_sum) or any(data['sum'][-5:] <= -total_sum)):
        return

    buy_indices = data.index[data['sum'] >= total_sum]
    sell_indices = data.index[data['sum'] <= -total_sum]

    for i, index in enumerate(buy_indices):
        if df.index.get_loc(index) >= len(df) - 5:
            p_cols = [col + f"({str(df.loc[index, col])})" for col in df.columns if df.loc[index, col] != 0]
            p = f"Sum: {data['sum'][index]}  indicators: {', '.join(p_cols)}"

            print("The Bullish sound")
            playsound('C:\\Users\\user\PycharmProjects\TradingAiVersion3\sounds\Bullish.wav')
            playsound('C:\\Users\\user\PycharmProjects\TradingAiVersion3\sounds\Bullish Voice.mp3')

            print(p)
    for i, index in enumerate(sell_indices):
        if df.index.get_loc(index) >= len(df) - 5:
            p_cols = [col + f"({str(df.loc[index, col])})" for col in df.columns if df.loc[index, col] != 0]
            p = f"Sum: {data['sum'][index]}  Non-zero indicators: {', '.join(p_cols)}"

            print("The Bearish sound")
            playsound('C:\\Users\\user\PycharmProjects\TradingAiVersion3\sounds\Bearish.wav')
            playsound('C:\\Users\\user\PycharmProjects\TradingAiVersion3\sounds\Bearish Voice.mp3')


            print(p)

# main()
while True:
    main()
    time.sleep(60)


You see in the main.py file how I manage to calculate the sum and I managed to print the indicator
also from that from file how I get the court.

You have to mix that main.py file with observation.py. That can able to print the indicator the way
main.py are able to print the indicators.
..........................................

please do not mix missing data or other things the goal is here to get the indicator nothing else
let me give you some code reference so you can understand that.


Code Reference from main.py:
    # Fetch the required symbol's information
    connection = sqlite3.connect(database)
    db_frame = GetDbDataframe(connection)
    data = db_frame.get_minute_data(target_symbol, 1, 90)
    df = db_frame.get_all_indicators(target_symbol, 1, 90)
    df.index = data.index
    df = df.add_prefix("1_")
    data['sum'] = df.sum(axis=1)
    times = [3, 5, 15, 30, 60, 4 * 60, 24 * 60, 7 * 24 * 60]
    total_sum_values = pd.Series(0, index=pd.DatetimeIndex([]))
    total_sum_values = total_sum_values.add(data['sum'], fill_value=0)

    for time in times:
        temp_data = db_frame.get_minute_data(target_symbol, time, 90)
        temp_df = db_frame.get_all_indicators(target_symbol, time, 90)
        temp_df.index = temp_data.index
        temp_data = temp_data[~temp_data.index.duplicated(keep='first')]
        temp_df = temp_df[~temp_df.index.duplicated(keep='first')]
        temp_df = temp_df.add_prefix(f"{time}m_")
        df = pd.concat([df, temp_df], axis=1)
        temp_data['sum'] = temp_df.sum(axis=1)
        total_sum_values = total_sum_values.add(temp_data['sum'], fill_value=0)

        # Print last 5 sum for each timeframe
        print(f"Last 5 sum for {time}m:")
        print(temp_data['sum'][-5:])

    total_sum_values = total_sum_values.fillna(0).astype(np.int16)
    df.fillna(0, inplace=True)
    data['sum'] = total_sum_values


work there on the observation.py

.................................................
I request you a single things again and again and again which is indicator so
the thing is I calculate sum, if the sum is above 500 or below 500 that give me
a buying or selling signal and my plot based on that and plot is showing total sum
which is great but what I need. what I need actually the some built from indicator values
so sum indicators which indicators give 100 and - 100 .

I want to print theme in a list .

..............................................

You see in the main.py  I have the court to print indicator and
I am giving you the example so that you can in focus and focus on only that
codes only that only part. nothing else .



    for time in times:
        temp_data = db_frame.get_minute_data(target_symbol, time, 90)
        temp_df = db_frame.get_all_indicators(target_symbol, time, 90)
        temp_df.index = temp_data.index
        temp_data = temp_data[~temp_data.index.duplicated(keep='first')]
        temp_df = temp_df[~temp_df.index.duplicated(keep='first')]
        temp_df = temp_df.add_prefix(f"{time}m_")
        df = pd.concat([df, temp_df], axis=1)
        temp_data['sum'] = temp_df.sum(axis=1)
        total_sum_values = total_sum_values.add(temp_data['sum'], fill_value=0)

        # Print last 5 sum for each timeframe
        print(f"Last 5 sum for {time}m:")
        print(temp_data['sum'][-5:])

    total_sum_values = total_sum_values.fillna(0).astype(np.int16)
    df.fillna(0, inplace=True)
    data['sum'] = total_sum_values



 Example of the print :
 Sum: 300  indicators: 1_CDLDOJI(100.0), 1_CDLHARAMI(100.0), 1_CDLHARAMICROSS(100.0), 1_CDLHOMINGPIGEON(100.0), 1_CDLSHORTLINE(-100.0)

 Whice come from :
 p_cols = [col + f"({str(df.loc[index, col])})" for col in df.columns if df.loc[index, col] != 0]
            p = f"Sum: {data['sum'][index]}  Non-zero indicators: {', '.join(p_cols)}"

 this two line of code.

 So Give me print like that.

 import sys
import os
import sqlite3
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from all_variable import Variable
from database_small.db_dataframe import GetDbDataframe

import time
start_time = time.time()
print("Script Start :", time.ctime())

# Set database path from Variable class
database = Variable.SMALL_DATABASE
# database = Variable.BIG_DATABASE

# Convert to absolute path
absolute_path = os.path.abspath(database)
print(f"Database path: {absolute_path}")

# Initialize global constants
LOOKBACK = 1440 / 32  # Lookback of 1 year (1440 minutes per day)
TOTAL_SUM = 500  # Updated total_sum to 1500
TIME_PERIODS = [1, 3, 5, 15, 30, 60, 4 * 60, 24 * 60, 7 * 24 * 60]  # Time periods

def get_database_connection():
    """Returns a connection to the SQLite database."""
    connection = sqlite3.connect(database)
    return connection


def fetch_resampled_data(symbol, time_period, lookback, db_frame):
    """Fetches resampled data and indicators for a given time period."""
    print(f"Fetching data for {symbol} at {time_period} minutes...")
    resampled_data = db_frame.get_minute_data(symbol, time_period, lookback)
    df = db_frame.get_all_indicators(symbol, time_period, lookback)

    if resampled_data.empty or df.empty:
        print(f"No data found for {symbol} at {time_period} minutes!")
        return None, None

    # Reindex df to match resampled_data index
    df.index = resampled_data.index
    resampled_data = resampled_data[~resampled_data.index.duplicated(keep='first')]
    df = df[~df.index.duplicated(keep='first')]

    return resampled_data, df


def calculate_total_sum(resampled_data, df):
    """Calculates the total sum of indicators and adds it to the resampled data."""
    resampled_data['sum'] = df.sum(axis=1)
    return resampled_data


def print_indicators_and_sum(resampled_data, df, total_sum_values, symbol):
    """Prints the sum and the indicators contributing to buy/sell signals."""
    if df is None:
        print("DataFrame is None. Skipping this timeframe.")
        return

    MIN_INDICATOR_THRESHOLD = 0.1  # Minimum threshold for considering indicator values
    df = df.reindex(resampled_data.index)

    for index in resampled_data.index:
        # Check if sum crosses threshold for buy/sell signal
        if total_sum_values[index] >= TOTAL_SUM:
            # Print the indicators that contributed to the buy signal
            contributing_indicators = [f'{col}({df[col].loc[index]:.2f})'
                                       for col in df.columns if df[col].loc[index] > MIN_INDICATOR_THRESHOLD]
            if contributing_indicators:
                print(f"Buy Signal at {index}: Sum: {total_sum_values[index]}  Indicators: {', '.join(contributing_indicators)}")
        elif total_sum_values[index] <= -TOTAL_SUM:
            # Print the indicators that contributed to the sell signal
            contributing_indicators = [f'{col}({df[col].loc[index]:.2f})'
                                       for col in df.columns if df[col].loc[index] < -MIN_INDICATOR_THRESHOLD]
            if contributing_indicators:
                print(f"Sell Signal at {index}: Sum: {total_sum_values[index]}  Indicators: {', '.join(contributing_indicators)}")


def plot_signals(resampled_data, total_sum_values, symbol, df):
    """Plots the close price along with buy and sell signals, and prints the indicators."""
    marker_sizes = np.abs(resampled_data['sum']) / 10

    # Print the indicators contributing to buy/sell signals
    print_indicators_and_sum(resampled_data, df, total_sum_values, symbol)

    # Plot the close price
    plt.figure(figsize=(14, 7))  # Set figure size for better visualization
    plt.plot(resampled_data['Close'], label='Close Price', color='blue', linewidth=1.5)

    # Buy and sell signal markers
    buy_indices = resampled_data.index[resampled_data['sum'] >= TOTAL_SUM]
    sell_indices = resampled_data.index[resampled_data['sum'] <= -TOTAL_SUM]

    plt.scatter(buy_indices, resampled_data['Close'][resampled_data['sum'] >= TOTAL_SUM],
                marker='^', s=marker_sizes[resampled_data['sum'] >= TOTAL_SUM], color='green', zorder=3,
                label='Buy Signal')
    plt.scatter(sell_indices, resampled_data['Close'][resampled_data['sum'] <= -TOTAL_SUM],
                marker='v', s=marker_sizes[resampled_data['sum'] <= -TOTAL_SUM], color='red', zorder=3,
                label='Sell Signal')

    # Add text labels for sum values
    for index in buy_indices:
        plt.text(index, resampled_data['Close'][index], f'{resampled_data["sum"][index]}',
                 ha='center', va='bottom', fontsize=8, color='green', fontweight='bold')
    for index in sell_indices:
        plt.text(index, resampled_data['Close'][index], f'{resampled_data["sum"][index]}',
                 ha='center', va='top', fontsize=8, color='red', fontweight='bold')

    # Time Counting
    end_time = time.time()
    print("End Time: ", end_time)
    print("Script is running for Creating Plot " + str(int((end_time - start_time) / 60)) + " Minutes.")

    # Title and Labels
    plt.title(f'{symbol} Price with Buy/Sell Signals', fontsize=16)
    plt.xlabel('Time', fontsize=12)
    plt.ylabel('Price (USD)', fontsize=12)
    plt.legend()
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.xticks(rotation=45)  # Rotate x-axis labels for better readability
    plt.tight_layout()  # Adjust the layout to prevent clipping
    # Full screen mode
    # plt.get_current_fig_manager().full_screen_toggle()
    plt.show()


def main(symbol):
    """Main function to run the entire process."""
    pd.set_option('mode.chained_assignment', None)
    pd.set_option('display.max_rows', 500)
    pd.set_option('display.max_columns', 500)
    pd.set_option('display.width', 1000)

    # Get database connection and fetch data
    connection = get_database_connection()
    db_frame = GetDbDataframe(connection)

    total_sum_values = pd.Series(0, index=pd.DatetimeIndex([]))

    # Fetch resampled data for each time period and accumulate the sum
    for time in TIME_PERIODS:
        resampled_data, df = fetch_resampled_data(symbol, time, LOOKBACK, db_frame)
        if resampled_data is None or df is None:
            continue
        resampled_data = calculate_total_sum(resampled_data, df)
        total_sum_values = total_sum_values.add(resampled_data['sum'], fill_value=0)

    total_sum_values = total_sum_values.fillna(0).astype(np.int16)

    # Final resampled data and plot
    resampled_data = db_frame.get_minute_data(symbol, 1, LOOKBACK)
    resampled_data['sum'] = total_sum_values

    plot_signals(resampled_data, total_sum_values, symbol, df)


# Call the function for BTCUSDT
if __name__ == "__main__":
    main("BTCUSDT")

I want that script to update not main.py.



